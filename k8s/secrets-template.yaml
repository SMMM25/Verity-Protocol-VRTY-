# Verity Protocol - Secrets Template
# IMPORTANT: Do NOT commit this file with actual values!
# Use this as a template and apply with kubectl create secret
#
# To create secrets from command line:
# kubectl create secret generic verity-secrets \
#   --namespace verity-protocol \
#   --from-literal=DATABASE_URL='postgresql://user:pass@host:5432/db' \
#   --from-literal=JWT_SECRET='your-jwt-secret' \
#   --from-literal=VERITY_ISSUER_SEED='your-issuer-seed'
#
# Or use sealed-secrets / external-secrets-operator for production
apiVersion: v1
kind: Secret
metadata:
  name: verity-secrets
  namespace: verity-protocol
type: Opaque
stringData:
  # Database connection
  DATABASE_URL: "postgresql://verity:CHANGE_ME@postgres:5432/verity_protocol?schema=public"
  
  # JWT Authentication
  JWT_SECRET: "CHANGE_ME_TO_64_CHAR_RANDOM_STRING"
  JWT_REFRESH_SECRET: "CHANGE_ME_TO_ANOTHER_64_CHAR_RANDOM_STRING"
  
  # XRPL Issuer (CRITICAL - store securely!)
  # VERITY_ISSUER_SEED: "NEVER_COMMIT_THIS_VALUE"
  
  # Bridge Secrets
  SOLANA_BRIDGE_PRIVATE_KEY: "CHANGE_ME"
  
  # External Service API Keys
  XUMM_API_KEY: "CHANGE_ME"
  XUMM_API_SECRET: "CHANGE_ME"
  
  # Redis (if using authentication)
  REDIS_PASSWORD: "CHANGE_ME"
  
  # Encryption keys
  ENCRYPTION_KEY: "CHANGE_ME_32_BYTE_KEY"
---
# External Secrets Operator example (recommended for production)
# apiVersion: external-secrets.io/v1beta1
# kind: ExternalSecret
# metadata:
#   name: verity-external-secrets
#   namespace: verity-protocol
# spec:
#   refreshInterval: 1h
#   secretStoreRef:
#     name: aws-secrets-manager
#     kind: ClusterSecretStore
#   target:
#     name: verity-secrets
#   data:
#     - secretKey: DATABASE_URL
#       remoteRef:
#         key: verity/production/database
#         property: url
#     - secretKey: JWT_SECRET
#       remoteRef:
#         key: verity/production/jwt
#         property: secret
